using System;
using System.Reflection.Emit;
using System.Reflection;
using Thomas.Database.Core.Provider;
using Thomas.Database.Configuration;
using System.Linq;

namespace Thomas.Database.Core.QueryGenerator
{
    //Reduce memory footprint by using a single type for all generated types
    internal partial class SqlGenerator<T> : IParameterHandler where T : class, new()
    {
        internal static Type BuildType(ReadOnlySpan<DbParameterInfo> dbParametersToBind)
        {
            var assemblyName = new AssemblyName("ThomasInternalAssembly");
            AssemblyBuilder ab = AssemblyBuilder.DefineDynamicAssembly(assemblyName, AssemblyBuilderAccess.Run);
            ModuleBuilder mb = ab.DefineDynamicModule(assemblyName.Name);
            TypeBuilder tb = mb.DefineType($"DynamicType{InternalCounters.GetNextTypeCounter()}", TypeAttributes.Public);

            var types = new Type[dbParametersToBind.Length];

            for (int i = 0; i < dbParametersToBind.Length; i++)
                types[i] = dbParametersToBind[i].PropertyType;

            ConstructorBuilder constructor = tb.DefineConstructor(MethodAttributes.Public, CallingConventions.Standard, types);
            ILGenerator ctorIL = constructor.GetILGenerator();

            ctorIL.Emit(OpCodes.Ldarg_0);
            ctorIL.Emit(OpCodes.Call, typeof(object).GetConstructor(Type.EmptyTypes));

            for (int i = 0; i < dbParametersToBind.Length; i++)
            {
                var dbParameter = dbParametersToBind[i];
                FieldBuilder field = tb.DefineField(dbParameter.Name, dbParameter.PropertyType, FieldAttributes.Public | FieldAttributes.InitOnly);

                // Generate IL for constructor to set readonly fields
                ctorIL.Emit(OpCodes.Ldarg_0); // Load the instance (this)
                EmitLoadArgument(ctorIL, i); // Load the object[index] argument
                if (!dbParameter.PropertyType.IsValueType)
                    ctorIL.Emit(OpCodes.Castclass, dbParameter.PropertyType); // Cast it if it's a reference type

                ctorIL.Emit(OpCodes.Stfld, field); // Set the field
                PropertyBuilder property = tb.DefineProperty(dbParameter.Name, PropertyAttributes.HasDefault, dbParameter.PropertyType, null);
                MethodBuilder getPropMthdBldr = tb.DefineMethod("get_" + dbParameter.Name,
                    MethodAttributes.Public | MethodAttributes.SpecialName | MethodAttributes.HideBySig,
                    dbParameter.PropertyType, Type.EmptyTypes);

                ILGenerator getIl = getPropMthdBldr.GetILGenerator();
                getIl.Emit(OpCodes.Ldarg_0);
                getIl.Emit(OpCodes.Ldfld, field);
                getIl.Emit(OpCodes.Ret);
                property.SetGetMethod(getPropMthdBldr);
            }

            // Finish the constructor
            ctorIL.Emit(OpCodes.Ret);

            return tb.CreateTypeInfo().AsType();
        }

        internal static Type BuildTypeFromParent<TParent>(ReadOnlySpan<DbParameterInfo> dbParametersToBind, bool excludeAutogenerateColumns)
        {
            var parentType = typeof(TParent);
            var assemblyName = new AssemblyName("ThomasInternalAssembly");
            var assemblyBuilder = AssemblyBuilder.DefineDynamicAssembly(assemblyName, AssemblyBuilderAccess.Run);
            var moduleBuilder = assemblyBuilder.DefineDynamicModule(assemblyName.Name);
            var tb = moduleBuilder.DefineType($"DynamicType{InternalCounters.GetNextTypeCounter()}", TypeAttributes.Public, parentType);

            Span<FieldBuilder> fieldBuilders = new FieldBuilder[dbParametersToBind.Length];
            var types = new Type[dbParametersToBind.Length + 1];
            types[0] = parentType;
            for (int i = 0; i < dbParametersToBind.Length; i++)
            {
                fieldBuilders[i] = tb.DefineField(dbParametersToBind[i].Name, dbParametersToBind[i].PropertyType, FieldAttributes.Public | FieldAttributes.InitOnly);
                types[i + 1] = fieldBuilders[i].FieldType;
            }

            var constructorBuilder = tb.DefineConstructor(MethodAttributes.Public, CallingConventions.Standard, types);
            var ilGenerator = constructorBuilder.GetILGenerator();

            // Define labels for try-catch
            Label tryStart = ilGenerator.BeginExceptionBlock();
            Label tryEnd = ilGenerator.DefineLabel();
            Label catchStart = ilGenerator.DefineLabel();

            ConstructorInfo EmptyConstructor = typeof(object).GetConstructor(Type.EmptyTypes)!;
            ilGenerator.Emit(OpCodes.Ldarg_0);
            ilGenerator.Emit(OpCodes.Call, EmptyConstructor);

            PropertyInfo[] properties;

            if (DbConfigurationFactory.Tables.ContainsKey(parentType.FullName!))
                properties = DbConfigurationFactory.Tables[parentType.FullName!].Columns.Where(x => x.Autogenerated != excludeAutogenerateColumns).Select(x => x.Property).ToArray();
            else
                properties = parentType.GetProperties(BindingFlags.Public | BindingFlags.Instance);

            foreach (var prop in properties)
            {
                ilGenerator.Emit(OpCodes.Ldarg_0); // Load the instance (this)
                ilGenerator.Emit(OpCodes.Ldarg_1); // Load the object[] argument
                ilGenerator.Emit(OpCodes.Castclass, parentType);
                var getMethod = prop.GetGetMethod();
                var setMethod = prop.GetSetMethod();
                if (getMethod != null && setMethod != null)
                {
                    ilGenerator.Emit(OpCodes.Callvirt, getMethod);
                    ilGenerator.Emit(OpCodes.Callvirt, setMethod);
                }
            }

            for (int i = 0; i < dbParametersToBind.Length; i++)
            {
                ilGenerator.Emit(OpCodes.Ldarg_0);
                EmitLoadArgument(ilGenerator, i + 1);
                if (!dbParametersToBind[i].PropertyType.IsValueType)
                    ilGenerator.Emit(OpCodes.Castclass, dbParametersToBind[i].PropertyType);

                ilGenerator.Emit(OpCodes.Stfld, fieldBuilders[i]);
                PropertyBuilder property = tb.DefineProperty(dbParametersToBind[i].Name, PropertyAttributes.HasDefault, fieldBuilders[i].FieldType, null);
                MethodBuilder getPropMthdBldr = tb.DefineMethod("get_" + dbParametersToBind[i].Name,
                    MethodAttributes.Public | MethodAttributes.SpecialName | MethodAttributes.HideBySig,
                    fieldBuilders[i].FieldType, Type.EmptyTypes);

                ILGenerator getIl = getPropMthdBldr.GetILGenerator();
                getIl.Emit(OpCodes.Ldarg_0);
                getIl.Emit(OpCodes.Ldfld, fieldBuilders[i]);
                getIl.Emit(OpCodes.Ret);
                property.SetGetMethod(getPropMthdBldr);
            }

            ilGenerator.Emit(OpCodes.Leave, tryEnd);

            // Catch block
            ilGenerator.BeginCatchBlock(typeof(Exception));

            // Exception handling code could go here
            ilGenerator.EmitWriteLine("Exception occurred");
            ilGenerator.Emit(OpCodes.Rethrow);  // re-throw the caught exception or handle accordingly

            ilGenerator.EndExceptionBlock();
            ilGenerator.MarkLabel(tryEnd);

            ilGenerator.Emit(OpCodes.Ret);

            return tb.CreateTypeInfo().AsType();
        }

        static void EmitLoadArgument(ILGenerator il, int i)
        {
            if (i == 0) il.Emit(OpCodes.Ldarg_1);
            else if (i == 1) il.Emit(OpCodes.Ldarg_2);
            else if (i == 2) il.Emit(OpCodes.Ldarg_3);
            else if (i >= 3) il.Emit(OpCodes.Ldarg_S, i + 1);
        }
    }
}
